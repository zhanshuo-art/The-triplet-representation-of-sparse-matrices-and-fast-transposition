# 稀疏矩阵存储与转置系统

## 项目简介
这是一个基于三元组顺序表的稀疏矩阵处理系统，用于构建论文-技术分类矩阵，实现高效的矩阵转置和乘法运算，分析机构合作潜力。

## 功能特点
- 📊 **稀疏矩阵存储**：使用三元组顺序表压缩存储大规模稀疏矩阵
- ⚡ **快速转置算法**：O(nums + cols) 时间复杂度完成矩阵转置
- 🔄 **矩阵乘法**：计算 A × A^T 生成机构合作潜力矩阵
- 💾 **多格式输出**：支持密集矩阵和三元组表示的CSV导出
- 📈 **性能统计**：显示算法执行时间和存储效率

## 核心技术

### 稀疏矩阵
稀疏矩阵是指矩阵中大部分元素为零的矩阵。例如一个 1000×5000 的矩阵，如果只有 10000 个非零元素，稀疏度高达 99.8%。

**传统存储方式的问题**：
- 二维数组存储：需要 1000 × 5000 = 500万 个单元
- 空间浪费：99.8% 的空间用于存储无用的零元素
- 内存占用：约 20MB（假设每个整数 4 字节）

**稀疏矩阵存储的优势**：
- 只存储非零元素
- 上述示例仅需存储 10000 个三元组 ≈ 120KB
- 压缩率：约 166 倍

### 三元组顺序表
三元组顺序表是稀疏矩阵的一种压缩存储方式，每个三元组包含：
- **row**：元素所在行号
- **col**：元素所在列号
- **value**：元素的值

**示例**：矩阵
```
    0   1   2   3
0 [ 0   0   3   0 ]
1 [ 0   5   0   0 ]
2 [ 0   0   0   7 ]
```

三元组表示：
```
(0, 2, 3)  // 第0行第2列值为3
(1, 1, 5)  // 第1行第1列值为5
(2, 3, 7)  // 第2行第3列值为7
```

### 快速转置算法
矩阵转置即行列互换（A^T[j][i] = A[i][j]）。

**普通转置**：
- 时间复杂度：O(nums × cols)
- 方法：按列扫描原矩阵，依次放入转置矩阵
- 问题：需要多次遍历原矩阵

**快速转置算法**：
- 时间复杂度：O(nums + cols)
- 核心思想：一次扫描即可完成转置
- 关键数据结构：
  - **num[col]**：统计原矩阵第 col 列的非零元素个数
  - **cpot[col]**：指示第 col 列第一个元素在转置矩阵中的位置

**算法步骤**：
1. 统计每列非零元素个数 → num 数组
2. 计算每列在转置矩阵中的起始位置 → cpot 数组
   ```
   cpot[0] = 0
   cpot[col] = cpot[col-1] + num[col-1]
   ```
3. 扫描原矩阵三元组，根据 cpot 直接放入转置矩阵对应位置
4. 每放入一个元素，cpot[col]++

### 机构合作潜力分析
通过计算 **A × A^T**（论文-技术矩阵与其转置的乘积）：
- **结果矩阵** [i][j]：表示论文 i 和论文 j 的技术重叠度
- **应用**：值越大表示两篇论文使用的技术越相似，所属机构合作潜力越大

## 数据处理流程
```
DeepDiveAI.csv (读取前1000篇论文)
         ↓
    提取论文ID列表
         ↓
DeepPatentAI.csv (读取IPC分类)
         ↓
  构建 论文×技术 矩阵 (A)
         ↓
    转换为三元组顺序表
         ↓
      快速转置 (A^T)
         ↓
   矩阵乘法 (A × A^T)
         ↓
    机构合作潜力矩阵
```

## 使用方法

### 1. 准备数据文件
需要两个 CSV 文件：
- **DeepDiveAI.csv**：包含论文ID（第2列）
- **DeepPatentAI.csv**：包含论文ID（第2列）和IPC分类（第4列）

### 2. 修改文件路径
在代码第5-6行修改为你的文件路径：
```cpp
const string PATH_DeepDiveAI   = "your_path/DeepDiveAI.csv";
const string PATH_DeepPatentAl = "your_path/DeepPatentAI.csv";
```

在代码第236、294、315、367行修改输出路径。

### 3. 调整参数（可选）
在代码第8行修改读取的论文数量：
```cpp
const int DEEPDIVE_FIRST_N = 1000;  // 默认读取前1000篇
```

### 4. 编译运行
```bash
g++ experiment_2_4nd.cpp -o sparse_matrix
./sparse_matrix
```

## 输出文件

生成 4 个 CSV 文件：

### 1. InstTechMatrix.csv
**密集矩阵表示**（论文 × 技术分类）
```csv
paper_id,G06K,H04N,G06F,...
10.1234/paper1,2,0,1,...
10.1234/paper2,0,3,0,...
```
- 行：论文ID
- 列：IPC技术分类（4位代码）
- 值：该论文使用该技术的次数

### 2. InstTechMatrix_triple.csv
**原始矩阵的三元组顺序表**
```csv
row_index,row_name,col_index,col_name,value
0,"10.1234/paper1",0,G06K,2
0,"10.1234/paper1",2,G06F,1
1,"10.1234/paper2",1,H04N,3
```

### 3. InstTechMatrix_transposed.csv
**转置矩阵的三元组顺序表**（技术分类 × 论文）
- 行列互换后的三元组表示

### 4. InstCollaborationMatrix.csv
**机构合作潜力矩阵**（论文 × 论文）
```csv
paper_id,"10.1234/paper1","10.1234/paper2",...
"10.1234/paper1",25,8,...
"10.1234/paper2",8,32,...
```
- 对角线元素：论文自身的技术多样性
- 非对角线元素：两篇论文的技术重叠度（值越大合作潜力越大）

## 输出示例
```
========== 开始构建 PaperTechMatrix ==========

读取 DeepDiveAI.csv...
已读取 100 行
...
DeepDiveAI 读取完毕: 1000 行, 唯一论文数: 987

读取 DeepPatentAI.csv...
样例1 - 原始IPC: ["G06K9/00"] -> 解析结果: [G06K]
...
DeepPatentAI 读取完毕: 125673 行

构建论文-技术矩阵...
矩阵构建完成, IPC分类数: 437

输出密集矩阵...
密集矩阵已保存: InstTechMatrix.csv

========== 开始三元组转换与转置 ==========
三元组顺序表构建完成
矩阵规模: 987 × 437
非零元素个数: 3254

执行快速转置算法...
快速转置完成，耗时: 12 毫秒

========== 计算机构合作潜力矩阵 ==========
矩阵乘法完成，耗时: 3248 毫秒

========== 所有任务完成 ==========
```

## 应用场景
- 科研机构合作网络分析
- 技术相似度计算
- 论文推荐系统（基于技术相似性）
- 稀疏矩阵算法学习
- 大规模数据压缩存储

## 算法复杂度

### 快速转置算法
- **时间复杂度**：O(nums + cols)
  - nums：非零元素个数
  - cols：列数
- **空间复杂度**：O(nums)

### 矩阵乘法 (A × A^T)
- **时间复杂度**：O(rows² × cols)
- **空间复杂度**：O(rows²)

## 性能优势
假设矩阵规模为 1000 × 5000，非零元素 10000 个：

| 操作 | 传统方法 | 三元组方法 |
|------|---------|-----------|
| 存储空间 | 20 MB | 120 KB |
| 转置时间 | O(5000 × 10000) | O(10000 + 5000) |
| 压缩率 | - | 约 166 倍 |

## 扩展功能建议
- 实现稀疏矩阵的加法和减法
- 优化矩阵乘法（使用稀疏矩阵乘法算法）
- 支持十字链表存储结构
- 添加矩阵可视化功能
- 实现并行计算加速
